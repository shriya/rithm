# Friday Jun 16

## Warm Up 

* [Quick Sort](https://repl.it/student/submissions/1135688)
* tricky; here is a quick sort solution: [quick sort exercise solution](https://github.com/rithmschool/javascript_computer_science_exercises/blob/solutions/sorting_algorithms_exercise/sorting.js)

## Meme Generator App

* We have JSON of all the memes with URLs, ids, title, height, and width
* we have to set the .env variables (IMG_FLIP_USERNAME, IMG_FLIP_PASSWORD, and SECRET_KEY) to our own account info for imgflip - never commit the .env because it's secret things (so put it in .gitignore) - people have scripts that go through github looking for API keys (like AWS - could cost you $$$!)

## Redux-Auth-Client-Server

* JWT is like a cookie but not stored as a cookie -- encoding and decoding into base 64 - [can do it ourselves here](https://jwt.io/)
* `Bearer ${token}`
* `jwtDecode` is an npm module that decodes the big token string
* `setCurrentUser` function has a `type: SET_CURRENT_USER` and a `user: user` -- redux knows the user is authenticated if this `user` objects exists, otherwise the authentication fails
* token was generated by our server (flask or node)

## Reviewing Old ES6 & React Stuff So I'm Less Confused

#### Functional Programming in Javascript

* An alternative to OOP
* Build programs with small reusable functions
* We want to always write **pure functions** that don't have side effects.
	* When a pure function is called with the same input, it will always give the same output **(idempotence)**. 
	* A pure function does not modify external state; it does not change values outside of its scope

example: 

```javascript
var arr = [2,4,6]
function doubleValues(arr){
    return arr.map(function(val){
        return val*2;
    });
}

doubleValues(arr); // [4,8,12]
doubleValues(arr); // [4,8,12]
doubleValues(arr); // [4,8,12]
```

#### _(Aside)_ `Object.assign`

[Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) copies values from one or more source objects to a target object; does not do a deep copy

```javascript
// cloning an object

var obj = { a: 1 };
var copy = Object.assign({}, obj);
console.log(copy); // { a: 1 }
``` 

```javascript
// merging objects together

var o1 = { a: 1 };
var o2 = { b: 2 };
var o3 = { c: 3 };

var obj = Object.assign(o1, o2, o3);
console.log(obj); // { a: 1, b: 2, c: 3 }
console.log(o1);  // { a: 1, b: 2, c: 3 }, target object itself is changed.
```

```js
// merging objects with same properties; overwritten

var o1 = { a: 1, b: 1, c: 1 };
var o2 = { b: 2, c: 2 };
var o3 = { c: 3 };

var obj = Object.assign({}, o1, o2, o3);
console.log(obj); // { a: 1, b: 2, c: 3 }
```

#### Back to Functional Programming

* Adding a property to an object in a **pure** way; creating a new object that has all existing properties plus new property merged:

```js
function addNameToObject(obj,val){
    var newObj = {name: val};
    return Object.assign({}, obj, newObj);
}
```














































************************************

## Questions 

* 

## Ideas & Notes

* 

## To Do

* 

## Coming up this week

* 